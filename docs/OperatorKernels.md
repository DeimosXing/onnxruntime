## Supported Operators Data Types
*This file is automatically generated from the
            [def files](/onnxruntime/core/providers/cpu/cpu_execution_provider.cc) via [this script](/tools/python/gen_opkernel_doc.py).
            Do not modify directly and instead edit operator definitions.*



## Operators implemented by CPUExecutionProvider

| Op Name | Parameters | OpSet Version | Types Supported |
|---------|------------|---------------|-----------------|
**Operator Domain:** *ai.onnx.ml*
|Abs|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(uint64), tensor(int32)|
|Acos|(*in* input:**T**, *out* output:**T**)|7+|**T** = tensor(float)|
|Acosh|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(float)|
|Add|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Affine|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|And|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|7+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|ArgMax|(*in* data:**T**, *out* reduced:**tensor(int64)**)|12+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
| | |[11, 11]|**T** = tensor(int32), tensor(float)|
|ArgMin|(*in* data:**T**, *out* reduced:**tensor(int64)**)|12+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
| | |[11, 11]|**T** = tensor(int32), tensor(float)|
|ArrayFeatureExtractor|(*in* X:**T**, *in* Y:**tensor(int64)**, *out* Z:**T**)|1+|**T** = tensor(double), tensor(string), tensor(float), tensor(int64), tensor(int32)|
|Asin|(*in* input:**T**, *out* output:**T**)|7+|**T** = tensor(float)|
|Asinh|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(float)|
|Atan|(*in* input:**T**, *out* output:**T**)|7+|**T** = tensor(float)|
|Atanh|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(float)|
|AveragePool|(*in* X:**T**, *out* Y:**T**)|11+|**T** = tensor(float)|
| | |[10, 10]|**T** = tensor(float)|
| | |[7, 9]|**T** = tensor(float)|
|BatchNormalization|(*in* X:**T**, *in* scale:**T**, *in* B:**T**, *in* mean:**T**, *in* var:**T**, *out* Y:**T**, *out* mean:**T**, *out* var:**T**, *out* saved_mean:**T**, *out* saved_var:**T**) or (*in* X:**T**, *in* scale:**T**, *in* B:**T**, *in* mean:**T**, *in* var:**T**, *in* training_mode:**T1**, *out* Y:**T**, *out* output_mean:**T**, *out* output_var:**T**, *out* saved_mean:**T**, *out* saved_var:**T**)|[7, 9]|**T** = tensor(double), tensor(float)|
|Binarizer|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|BitShift|(*in* X:**T**, *in* Y:**T**, *out* Z:**T**)|11+|**T** = tensor(uint32), tensor(uint64), tensor(uint8)|
|Cast|(*in* input:**T1**, *out* output:**T2**)|9+|**T1** = tensor(string)|
| | ||**T2** = tensor(double), tensor(string), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[6, 9]|**T1** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(string), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|CastMap|(*in* X:**T1**, *out* Y:**T2**)|1+|**T1** = map(int64,tensor(string)), map(int64,tensor(float))|
| | ||**T2** = tensor(string), tensor(int64), tensor(float)|
|CategoryMapper|(*in* X:**T1**, *out* Y:**T2**)|1+|**T1** = tensor(string), tensor(int64)|
| | ||**T2** = tensor(string), tensor(int64)|
|Ceil|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|Clip|(*in* input:**T**, *out* output:**T**) or (*in* input:**T**, *in* min:**T**, *in* max:**T**, *out* output:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(uint64)|
| | |[11, 11]|**T** = tensor(float)|
| | |[6, 10]|**T** = tensor(float)|
|Compress|(*in* input:**T**, *in* condition:**T1**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(bool)|
| | |[9, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(bool)|
|Concat|(*in* inputs:**T**, *out* concat_result:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[4, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|ConcatFromSequence|(*in* input_sequence:**S**, *out* concat_result:**T**)|11+|**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
|ConstantOfShape|(*in* input:**T1**, *out* output:**T2**)|9+|**T1** = tensor(int64)|
| | ||**T2** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Conv|(*in* X:**T**, *in* W:**T**, *in* B:**T**, *out* Y:**T**)|11+|**T** = tensor(float)|
| | |[1, 10]|**T** = tensor(float)|
|ConvInteger|(*in* x:**T1**, *in* w:**T2**, *in* x_zero_point:**T1**, *in* w_zero_point:**T2**, *out* y:**T3**)|10+|**T1** = tensor(uint8)|
| | ||**T2** = tensor(uint8)|
| | ||**T3** = tensor(int32)|
|ConvTranspose|(*in* X:**T**, *in* W:**T**, *in* B:**T**, *out* Y:**T**)|11+|**T** = tensor(float)|
| | |[1, 10]|**T** = tensor(float)|
|Cos|(*in* input:**T**, *out* output:**T**)|7+|**T** = tensor(float)|
|Cosh|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(float)|
|Crop|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|CumSum|(*in* x:**T**, *in* axis:**T2**, *out* y:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
| | ||**T2** = tensor(int32), tensor(int64)|
|DepthToSpace|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(float)|
| | |[1, 10]|**T** = tensor(float)|
|DequantizeLinear|(*in* x:**T**, *in* x_scale:**tensor(float)**, *in* x_zero_point:**T**, *out* y:**tensor(float)**)|10+|**T** = tensor(int8), tensor(uint8)|
|Det|(*in* X:**T**, *out* Y:**T**)|11+|**T** = tensor(float)|
|DictVectorizer|(*in* X:**T1**, *out* Y:**T2**)|1+|**T1** = map(int64,tensor(float)), map(string,tensor(double)), map(int64,tensor(string)), map(int64,tensor(double)), map(string,tensor(int64)), map(string,tensor(float))|
| | ||**T2** = tensor(double), tensor(string), tensor(int64), tensor(float)|
|Div|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Dropout|(*in* data:**T**, *out* output:**T**, *out* mask:**T1**) or (*in* data:**T**, *in* ratio:**T1**, *out* output:**T**, *out* mask:**T2**) or (*in* data:**T**, *out* output:**T**, *out* mask:**T**)|10+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(bool)|
| | |[7, 9]|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(bool)|
|DynamicQuantizeLinear|(*in* x:**T1**, *out* y:**T2**, *out* y_scale:**tensor(float)**, *out* y_zero_point:**T2**)|11+|**T2** = tensor(uint8)|
|DynamicSlice|(*in* data:**T**, *in* starts:**Tind**, *in* ends:**Tind**, *in* axes:**Tind**, *out* output:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|Elu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|Equal|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|11+|**T** = tensor(int32), tensor(int64), tensor(float), tensor(bool)|
| | ||**T1** = tensor(bool)|
| | |[7, 10]|**T** = tensor(int32), tensor(int64), tensor(bool)|
| | ||**T1** = tensor(bool)|
|Erf|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(float)|
|Exp|(*in* input:**T**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float)|
|Expand|(*in* input:**T**, *in* shape:**tensor(int64)**, *out* output:**T**)|8+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|EyeLike|(*in* input:**T1**, *out* output:**T2**)|9+|**T1** = tensor(double), tensor(float), tensor(int64), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(float), tensor(int64), tensor(uint64), tensor(int32)|
|FeatureVectorizer|(*in* X:**T1**, *out* Y:**tensor(float)**)|1+|**T1** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Flatten|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 8]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[9, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Floor|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|GRU|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *out* Y:**T**, *out* Y_h:**T**)|7+|**T** = tensor(double), tensor(float)|
| | ||**T1** = tensor(int32)|
|Gather|(*in* data:**T**, *in* indices:**Tind**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
| | |[1, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|GatherElements|(*in* data:**T**, *in* indices:**Tind**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|GatherND|(*in* data:**T**, *in* indices:**tensor(int64)**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int64)|
|Gemm|(*in* A:**T**, *in* B:**T**, *in* C:**T**, *out* Y:**T**)|11+|**T** = tensor(float)|
| | |[7, 8]|**T** = tensor(float)|
| | |[9, 10]|**T** = tensor(float)|
|GlobalAveragePool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|GlobalLpPool|(*in* X:**T**, *out* Y:**T**)|2+|**T** = tensor(float)|
|GlobalMaxPool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|Greater|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|9+|**T** = tensor(int32), tensor(int64)|
| | ||**T1** = tensor(bool)|
| | |[7, 9]|**T** = tensor(float)|
| | ||**T1** = tensor(bool)|
|HardSigmoid|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|Hardmax|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(float)|
| | |[1, 10]|**T** = tensor(float)|
|Identity|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|If|(*in* cond:**B**, *out* outputs:**V**)|11+|**B** = tensor(bool)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**B** = tensor(bool)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|ImageScaler|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|Imputer|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(int64), tensor(float)|
|InstanceNormalization|(*in* input:**T**, *in* scale:**T**, *in* B:**T**, *out* output:**T**)|6+|**T** = tensor(float)|
|IsInf|(*in* X:**T1**, *out* Y:**T2**)|10+|**T1** = tensor(double), tensor(float)|
| | ||**T2** = tensor(bool)|
|IsNaN|(*in* X:**T1**, *out* Y:**T2**)|9+|**T1** = tensor(float16), tensor(float)|
| | ||**T2** = tensor(bool)|
|LRN|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|LSTM|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *in* initial_c:**T**, *in* P:**T**, *out* Y:**T**, *out* Y_h:**T**, *out* Y_c:**T**)|7+|**T** = tensor(double), tensor(float)|
| | ||**T1** = tensor(int32)|
|LabelEncoder|(*in* X:**T1**, *out* Y:**T2**)|2+|**T1** = tensor(string), tensor(float), tensor(int64)|
| | ||**T2** = tensor(string), tensor(float), tensor(int64)|
| | |[1, 1]|**T1** = tensor(string), tensor(int64)|
| | ||**T2** = tensor(string), tensor(int64)|
|LayerNormalization|(*in* X:**T**, *in* scale:**T**, *in* B:**T**, *out* Y:**T**, *out* mean:**U**, *out* inv_std_var:**U**)|1+|**T** = tensor(double), tensor(float)|
|LeakyRelu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|Less|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|9+|**T** = tensor(int32), tensor(int64)|
| | ||**T1** = tensor(bool)|
| | |[7, 9]|**T** = tensor(double), tensor(float)|
| | ||**T1** = tensor(bool)|
|LinearClassifier|(*in* X:**T1**, *out* Y:**T2**, *out* Z:**tensor(float)**)|1+|**T1** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
| | ||**T2** = tensor(string), tensor(int64)|
|LinearRegressor|(*in* X:**T**, *out* Y:**tensor(float)**)|1+|**T** = tensor(float)|
|Log|(*in* input:**T**, *out* output:**T**)|6+|**T** = tensor(float)|
|LogSoftmax|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float)|
|Loop|(*in* M:**I**, *in* cond:**B**, *in* v_initial:**V**, *out* v_final_and_scan_outputs:**V**)|11+|**B** = tensor(bool)|
| | ||**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**B** = tensor(bool)|
| | ||**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|LpNormalization|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|LpPool|(*in* X:**T**, *out* Y:**T**)|11+|**T** = tensor(float)|
| | |[2, 10]|**T** = tensor(float)|
|MatMul|(*in* A:**T**, *in* B:**T**, *out* Y:**T**)|9+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(uint64), tensor(int32)|
| | |[1, 8]|**T** = tensor(double), tensor(float)|
|MatMulInteger|(*in* A:**T1**, *in* B:**T2**, *in* a_zero_point:**T1**, *in* b_zero_point:**T2**, *out* Y:**T3**)|10+|**T1** = tensor(uint8)|
| | ||**T2** = tensor(int8), tensor(uint8)|
| | ||**T3** = tensor(int32)|
|Max|(*in* data_0:**T**, *out* max:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | |[6, 7]|**T** = tensor(float)|
| | |[8, 11]|**T** = tensor(double), tensor(float)|
| | ||**T1** = tensor(double), tensor(float)|
|MaxPool|(*in* X:**T**, *out* Y:**T**, *out* Indices:**I**) or (*in* X:**T**, *out* Y:**T**)|12+|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(int8), tensor(float), tensor(uint8)|
| | |[1, 7]|**T** = tensor(float)|
| | |[8, 11]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float)|
|MaxRoiPool|(*in* X:**T**, *in* rois:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|MaxUnpool|(*in* X:**T1**, *in* I:**T2**, *in* output_shape:**T2**, *out* output:**T1**)|11+|**T1** = tensor(float)|
| | ||**T2** = tensor(int64)|
| | |[9, 10]|**T1** = tensor(float)|
| | ||**T2** = tensor(int64)|
|Mean|(*in* data_0:**T**, *out* mean:**T**)|8+|**T** = tensor(float)|
| | |[6, 7]|**T** = tensor(float)|
|MeanVarianceNormalization|(*in* input:**T**, *out* output:**T**) or (*in* X:**T**, *out* Y:**T**)|9+|**T** = tensor(float)|
| | |[1, 8]|**T** = tensor(float)|
|Min|(*in* data_0:**T**, *out* min:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | |[6, 7]|**T** = tensor(float)|
| | |[8, 11]|**T** = tensor(float)|
| | ||**T1** = tensor(float)|
|Mod|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|10+|**T** = tensor(double), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(uint64), tensor(int32)|
|Mul|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Multinomial|(*in* input:**T1**, *out* output:**T2**)|7+|**T1** = tensor(float)|
| | ||**T2** = tensor(int32), tensor(int64)|
|Neg|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(int32)|
|NonZero|(*in* X:**T**, *out* Y:**tensor(int64)**)|9+|**T** = tensor(float), tensor(int64), tensor(uint8), tensor(bool), tensor(int32)|
|Normalizer|(*in* X:**T**, *out* Y:**tensor(float)**)|1+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Not|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|OneHot|(*in* indices:**T1**, *in* depth:**T2**, *in* values:**T3**, *out* output:**T3**)|11+|**T1** = tensor(int32), tensor(int64), tensor(float)|
| | ||**T2** = tensor(int32), tensor(int64), tensor(float)|
| | ||**T3** = tensor(string), tensor(int32), tensor(int64), tensor(float)|
| | |[9, 10]|**T1** = tensor(int32), tensor(int64), tensor(float)|
| | ||**T2** = tensor(int32), tensor(int64), tensor(float)|
| | ||**T3** = tensor(string), tensor(int32), tensor(int64), tensor(float)|
|OneHotEncoder|(*in* X:**T**, *out* Y:**tensor(float)**)|1+|**T** = tensor(double), tensor(string), tensor(int64), tensor(float)|
|Or|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|7+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|PRelu|(*in* X:**T**, *in* slope:**T**, *out* Y:**T**)|[7, 9]|**T** = tensor(float)|
|Pad|(*in* data:**T**, *in* pads:**tensor(int64)**, *in* constant_value:**T**, *out* output:**T**) or (*in* data:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
| | |[2, 10]|**T** = tensor(float)|
|ParametricSoftplus|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|Pow|(*in* X:**T**, *in* Y:**T**, *out* Z:**T**) or (*in* X:**T**, *in* Y:**T1**, *out* Z:**T**)|7+|**T** = tensor(double), tensor(float)|
|QLinearConv|(*in* x:**T1**, *in* x_scale:**tensor(float)**, *in* x_zero_point:**T1**, *in* w:**T2**, *in* w_scale:**tensor(float)**, *in* w_zero_point:**T2**, *in* y_scale:**tensor(float)**, *in* y_zero_point:**T3**, *in* B:**T4**, *out* y:**T3**)|10+|**T1** = tensor(uint8)|
| | ||**T2** = tensor(uint8)|
| | ||**T3** = tensor(uint8)|
| | ||**T4** = tensor(int32)|
|QLinearMatMul|(*in* a:**T1**, *in* a_scale:**tensor(float)**, *in* a_zero_point:**T1**, *in* b:**T2**, *in* b_scale:**tensor(float)**, *in* b_zero_point:**T2**, *in* y_scale:**tensor(float)**, *in* y_zero_point:**T3**, *out* y:**T3**)|10+|**T1** = tensor(uint8)|
| | ||**T2** = tensor(uint8)|
| | ||**T3** = tensor(uint8)|
|QuantizeLinear|(*in* x:**T1**, *in* y_scale:**tensor(float)**, *in* y_zero_point:**T2**, *out* y:**T2**)|10+|**T1** = tensor(float)|
| | ||**T2** = tensor(int8), tensor(uint8)|
|RNN|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *out* Y:**T**, *out* Y_h:**T**)|7+|**T** = tensor(float)|
| | ||**T1** = tensor(int32)|
|RandomNormal|(*out* output:**T**)|1+|**T** = tensor(double), tensor(float)|
|RandomNormalLike|(*in* input:**T1**, *out* output:**T2**)|1+|**T1** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(float)|
|RandomUniform|(*out* output:**T**)|1+|**T** = tensor(double), tensor(float)|
|RandomUniformLike|(*in* input:**T1**, *out* output:**T2**)|1+|**T1** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(float)|
|Range|(*in* start:**T**, *in* limit:**T**, *in* delta:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(float), tensor(int64), tensor(int16), tensor(int32)|
|Reciprocal|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|ReduceL1|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
|ReduceL2|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
|ReduceLogSum|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
|ReduceLogSumExp|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
|ReduceMax|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(int64), tensor(float)|
| | |12+|**T** = tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int32)|
| | |[1, 10]|**T** = tensor(int32), tensor(int64), tensor(float)|
|ReduceMean|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
|ReduceMin|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(int64), tensor(float)|
| | |12+|**T** = tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int32)|
| | |[1, 10]|**T** = tensor(int32), tensor(int64), tensor(float)|
|ReduceProd|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(int64), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(int64), tensor(float)|
|ReduceSum|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(int64), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(int64), tensor(float)|
|ReduceSumSquare|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(int32), tensor(float)|
| | |[1, 10]|**T** = tensor(int32), tensor(float)|
|Relu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|Reshape|(*in* data:**T**, *in* shape:**tensor(int64)**, *out* reshaped:**T**) or (*in* data:**T**, *out* reshaped:**T**)|5+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**shape** = tensor(int64)|
|Reshape_1||[1, 4]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Resize|(*in* X:**T1**, *in* roi:**T2**, *in* scales:**tensor(float)**, *in* sizes:**tensor(int64)**, *out* Y:**T1**) or (*in* X:**T**, *in* scales:**tensor(float)**, *out* Y:**T**)|11+|**T1** = tensor(int32), tensor(float), tensor(uint8)|
| | |[10, 10]|**T** = tensor(int32), tensor(float), tensor(uint8)|
|ReverseSequence|(*in* input:**T**, *in* sequence_lens:**tensor(int64)**, *out* Y:**T**)|10+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|RoiAlign|(*in* X:**T1**, *in* rois:**T1**, *in* batch_indices:**T2**, *out* Y:**T1**)|10+|**T** = tensor(double), tensor(float)|
| | ||**T2** = tensor(int64)|
|Round|(*in* X:**T**, *out* Y:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
|SVMClassifier|(*in* X:**T1**, *out* Y:**T2**, *out* Z:**tensor(float)**)|1+|**T1** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
| | ||**T2** = tensor(string), tensor(int64)|
|SVMRegressor|(*in* X:**T**, *out* Y:**tensor(float)**)|1+|**T** = tensor(float)|
|Scale|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|ScaledTanh|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|Scaler|(*in* X:**T**, *out* Y:**tensor(float)**)|1+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Scan|(*in* sequence_lens:**I**, *in* initial_state_and_scan_inputs:**V**, *out* final_state_and_scan_outputs:**V**) or (*in* initial_state_and_scan_inputs:**V**, *out* final_state_and_scan_outputs:**V**)|11+|**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[8, 8]|**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[9, 10]|**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Scatter|(*in* data:**T**, *in* indices:**Tind**, *in* updates:**T**, *out* output:**T**)|[9, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|ScatterElements|(*in* data:**T**, *in* indices:**Tind**, *in* updates:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|ScatterND|(*in* data:**T**, *in* indices:**tensor(int64)**, *in* updates:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int64)|
|Selu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|SequenceAt|(*in* input_sequence:**S**, *in* position:**I**, *out* tensor:**T**)|11+|**I** = tensor(int32), tensor(int64)|
| | ||**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
| | ||**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|SequenceConstruct|(*in* inputs:**T**, *out* output_sequence:**S**)|11+|**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
| | ||**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|SequenceEmpty|(*out* output:**S**)|11+|**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
|SequenceErase|(*in* input_sequence:**S**, *in* position:**I**, *out* output_sequence:**S**)|11+|**I** = tensor(int32), tensor(int64)|
| | ||**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
|SequenceInsert|(*in* input_sequence:**S**, *in* tensor:**T**, *in* position:**I**, *out* output_sequence:**S**)|11+|**I** = tensor(int32), tensor(int64)|
| | ||**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
|SequenceLength|(*in* input_sequence:**S**, *out* length:**I**)|11+|**I** = tensor(int64)|
| | ||**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
|Shape|(*in* data:**T**, *out* shape:**T1**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(int64)|
|Shrink|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(uint64), tensor(int32)|
|Sigmoid|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(float)|
|Sign|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(uint64), tensor(int32)|
|Sin|(*in* input:**T**, *out* output:**T**)|7+|**T** = tensor(double), tensor(float)|
|Sinh|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(float)|
|Size|(*in* data:**T**, *out* size:**T1**)|1+|**T** = tensor(double), tensor(string), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(int64)|
|Slice|(*in* data:**T**, *in* starts:**Tind**, *in* ends:**Tind**, *in* axes:**Tind**, *in* steps:**Tind**, *out* output:**T**) or (*in* data:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
| | |[1, 9]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[10, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|Softmax|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float)|
|Softplus|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|Softsign|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|SpaceToDepth|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|Split|(*in* input:**T**, *in* split:**T**, *out* outputs...:**T**) or (*in* input:**T**, *out* outputs:**T**)|11+|**T** = tensor(string), tensor(int32), tensor(int64), tensor(float)|
| | |[2, 10]|**T** = tensor(string), tensor(int32), tensor(int64), tensor(float)|
|SplitToSequence|(*in* input:**T**, *in* split:**I**, *out* output_sequence:**S**)|11+|**I** = tensor(int32), tensor(int64)|
| | ||**S** = seq(tensor(int8)), seq(tensor(bfloat16)), seq(tensor(uint64)), seq(tensor(float)), seq(tensor(uint16)), seq(tensor(int64)), seq(tensor(uint32)), seq(tensor(float16)), seq(tensor(bool)), seq(tensor(string)), seq(tensor(uint8)), seq(tensor(double)), seq(tensor(int32)), seq(tensor(int16))|
| | ||**T** = tensor(double), tensor(int32), tensor(string), tensor(float)|
|Sqrt|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float)|
|Squeeze|(*in* data:**T**, *out* squeezed:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|StringNormalizer|(*in* X:**tensor(string)**, *out* Y:**tensor(string)**)|10+|**T** = tensor(string)|
|Sub|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
|Sum|(*in* data_0:**T**, *out* sum:**T**)|8+|**T** = tensor(float)|
| | |[6, 7]|**T** = tensor(float)|
|Tan|(*in* input:**T**, *out* output:**T**)|7+|**T** = tensor(float)|
|Tanh|(*in* input:**T**, *out* output:**T**)|6+|**T** = tensor(float)|
|TfIdfVectorizer|(*in* X:**T**, *out* Y:**T1**)|9+|**T** = tensor(int32), tensor(string), tensor(int64)|
| | ||**T1** = tensor(float)|
|ThresholdedRelu|(*in* X:**T**, *out* Y:**T**)|10+|**T** = tensor(float)|
| | |[1, 9]|**T** = tensor(float)|
|Tile|(*in* input:**T**, *in* tiles:**T**, *in* axis:**T**, *out* output:**T**) or (*in* input:**T**, *in* repeats:**T1**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(int64)|
|TopK|(*in* X:**T**, *in* K:**tensor(int64)**, *out* Values:**T**, *out* Indices:**I**) or (*in* X:**T**, *out* Values:**T**, *out* Indices:**I**)|11+|**I** = tensor(int64)|
| | ||**T** = tensor(int64), tensor(float)|
| | |[1, 9]|**I** = tensor(int64)|
| | ||**T** = tensor(float)|
| | |[10, 10]|**I** = tensor(int64)|
| | ||**T** = tensor(float)|
|Transpose|(*in* data:**T**, *out* transposed:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|TreeEnsembleClassifier|(*in* X:**T1**, *out* Y:**T2**, *out* Z:**tensor(float)**)|1+|**T1** = tensor(double), tensor(int32), tensor(int64), tensor(float)|
| | ||**T2** = tensor(string), tensor(int64)|
|TreeEnsembleRegressor|(*in* X:**T**, *out* Y:**tensor(float)**)|1+|**T** = tensor(double), tensor(float)|
|Unique|(*in* X:**T**, *out* Y:**T**, *out* indices:**tensor(int64)**, *out* inverse_indices:**tensor(int64)**, *out* counts:**tensor(int64)**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Unsqueeze|(*in* data:**T**, *out* expanded:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Upsample|(*in* X:**T**, *in* scales:**tensor(float)**, *out* Y:**T**) or (*in* X:**T**, *out* Y:**T**)|[7, 9]|**T** = tensor(int32), tensor(float), tensor(uint8)|
|Where|(*in* condition:**B**, *in* X:**T**, *in* Y:**T**, *out* output:**T**)|9+|**T** = tensor(string), tensor(float), tensor(int64), tensor(uint8), tensor(int32)|
|Xor|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|7+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|ZipMap|(*in* X:**tensor(float)**, *out* Z:**T**)|1+|**T** = seq(map(string,tensor(float))), seq(map(int64,tensor(float)))|
| |
| |
**Operator Domain:** *com.microsoft*
|Attention|(*in* input:**T**, *in* weight:**T**, *in* bias:**T**, *in* mask_index:**M**, *out* output:**T**)|1+|**T** = tensor(float)|
|AttnLSTM|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *in* initial_c:**T**, *in* P:**T**, *in* QW:**T**, *in* MW:**T**, *in* V:**T**, *in* M:**T**, *in* memory_seq_lens:**T1**, *in* AW:**T**, *out* Y:**T**, *out* Y_h:**T**, *out* Y_c:**T**)|1+|**T** = tensor(double), tensor(float)|
| | ||**T1** = tensor(int32)|
|BiasGelu|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|1+|**T** = tensor(float)|
|CDist|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|1+|**T** = tensor(double), tensor(float)|
|ConvTransposeWithDynamicPads|(*in* X:**T**, *in* W:**T**, *in* Pads:**tensor(int64)**, *in* B:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|CropAndResize|(*in* X:**T1**, *in* rois:**T1**, *in* batch_indices:**T2**, *in* crop_size:**T2**, *out* Y:**T1**)|1+|**T** = tensor(float)|
| | ||**T2** = tensor(int32)|
|DequantizeLinear|(*in* x:**T2**, *in* x_scale:**T1**, *in* x_zero_point:**T2**, *out* y:**T1**)|1+|**T1** = tensor(float)|
| | ||**T2** = tensor(int8), tensor(uint8)|
|EmbedLayerNormalization|(*in* input_ids:**T1**, *in* segment_ids:**T1**, *in* word_embedding:**T**, *in* position_embedding:**T**, *in* segment_embedding:**T**, *in* gamma:**T**, *in* beta:**T**, *in* mask:**T1**, *out* output:**T**, *out* mask_index:**T1**)|1+|**T** = tensor(float)|
|ExpandDims|(*in* X:**T**, *in* axis:**tensor(int32)**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**axis** = tensor(int32)|
|FastGelu|(*in* X:**T**, *in* bias:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|FusedConv|(*in* X:**T**, *in* W:**T**, *in* B:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|FusedGemm|(*in* A:**T**, *in* B:**T**, *in* C:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|GatherND|(*in* data:**T**, *in* indices:**Tind**, *out* output:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|Gelu|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|MatMulInteger16|(*in* A:**T1**, *in* B:**T2**, *out* Y:**T3**)|1+|**T1** = tensor(int16)|
| | ||**T2** = tensor(int16)|
| | ||**T3** = tensor(int32)|
|MaxpoolWithMask|(*in* X:**T**, *in* M:**tensor(int32)**, *out* Y:**T**)|1+|**X** = tensor(float)|
|MurmurHash3|(*in* X:**T1**, *out* Y:**T2**)|1+|**T1** = tensor(uint32), tensor(int32), tensor(string)|
| | ||**T2** = tensor(uint32), tensor(int32)|
|Pad|(*in* data:**T**, *in* pads:**tensor(int64)**, *in* value:**T**, *out* output:**T**)|1+|**T** = tensor(float)|
|QuantizeLinear|(*in* x:**T1**, *in* y_scale:**T1**, *in* y_zero_point:**T2**, *out* y:**T2**)|1+|**T1** = tensor(float)|
| | ||**T2** = tensor(uint8)|
|Range|(*in* start:**T**, *in* limit:**T**, *in* delta:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float), tensor(int64), tensor(int16), tensor(int32)|
|SampleOp|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|SkipLayerNormalization|(*in* input:**T**, *in* skip:**T**, *in* gamma:**T**, *in* beta:**T**, *in* bias:**T**, *out* output:**T**, *out* mean:**U**, *out* inv_std_var:**U**)|1+|**T** = tensor(double), tensor(float)|
|Tokenizer|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(string)|
|Unique|(*in* x:**T**, *out* y:**T**, *out* idx:**tensor(int64)**, *out* counts:**tensor(int64)**)|1+|**T** = tensor(float)|
|WordConvEmbedding|(*in* Sequence:**T**, *in* W:**T1**, *in* B:**T1**, *in* C:**T1**, *out* Y:**T1**)|1+|**T** = tensor(int32)|
| | ||**T1** = tensor(float)|
| |
| |
**Operator Domain:** *com.microsoft.nchwc*
|AveragePool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|Conv|(*in* X:**T**, *in* W:**T**, *in* B:**T**, *in* Sum:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|GlobalAveragePool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|GlobalMaxPool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|MaxPool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|ReorderInput|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|ReorderOutput|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|Upsample|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
| |
| |


## Operators implemented by CUDAExecutionProvider

| Op Name | Parameters | OpSet Version | Types Supported |
|---------|------------|---------------|-----------------|
**Operator Domain:** *ai.onnx.ml*
|Abs|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(uint64), tensor(int32)|
|Add|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
|Affine|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|And|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|7+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|ArgMax|(*in* data:**T**, *out* reduced:**tensor(int64)**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|ArgMin|(*in* data:**T**, *out* reduced:**tensor(int64)**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|AveragePool|(*in* X:**T**, *out* Y:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[10, 10]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float16), tensor(float)|
| | |[7, 9]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float16), tensor(float)|
|BatchNormalization|(*in* X:**T**, *in* scale:**T**, *in* B:**T**, *in* mean:**T**, *in* var:**T**, *out* Y:**T**, *out* mean:**T**, *out* var:**T**, *out* saved_mean:**T**, *out* saved_var:**T**) or (*in* X:**T**, *in* scale:**T**, *in* B:**T**, *in* mean:**T**, *in* var:**T**, *in* training_mode:**T1**, *out* Y:**T**, *out* output_mean:**T**, *out* output_var:**T**, *out* saved_mean:**T**, *out* saved_var:**T**)|9+|**B** = tensor(double), tensor(float16), tensor(float)|
| | ||**X** = tensor(double), tensor(float16), tensor(float)|
| | ||**mean** = tensor(double), tensor(float16), tensor(float)|
| | ||**scale** = tensor(double), tensor(float16), tensor(float)|
| | ||**var** = tensor(double), tensor(float16), tensor(float)|
| | |[7, 8]|**B** = tensor(double), tensor(float16), tensor(float)|
| | ||**X** = tensor(double), tensor(float16), tensor(float)|
| | ||**mean** = tensor(double), tensor(float16), tensor(float)|
| | ||**scale** = tensor(double), tensor(float16), tensor(float)|
| | ||**var** = tensor(double), tensor(float16), tensor(float)|
|Cast|(*in* input:**T1**, *out* output:**T2**)|9+|**T1** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[6, 8]|**T1** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Ceil|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Clip|(*in* input:**T**, *out* output:**T**) or (*in* input:**T**, *in* min:**T**, *in* max:**T**, *out* output:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(uint64)|
| | |[11, 11]|**T** = tensor(float)|
| | |[6, 10]|**T** = tensor(float)|
|Compress|(*in* input:**T**, *in* condition:**T1**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(bool)|
| | |[9, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(bool)|
|Concat|(*in* inputs:**T**, *out* concat_result:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[4, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|ConstantOfShape|(*in* input:**T1**, *out* output:**T2**)|9+|**T1** = tensor(int64)|
| | ||**T2** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Conv|(*in* X:**T**, *in* W:**T**, *in* B:**T**, *out* Y:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|ConvTranspose|(*in* X:**T**, *in* W:**T**, *in* B:**T**, *out* Y:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|Crop|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|CumSum|(*in* x:**T**, *in* axis:**T2**, *out* y:**T**)|11+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(int32), tensor(int64)|
|DequantizeLinear|(*in* x:**T**, *in* x_scale:**tensor(float)**, *in* x_zero_point:**T**, *out* y:**tensor(float)**)|10+|**T** = tensor(int8), tensor(uint8)|
|Div|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
|Dropout|(*in* data:**T**, *out* output:**T**, *out* mask:**T1**) or (*in* data:**T**, *in* ratio:**T1**, *out* output:**T**, *out* mask:**T2**) or (*in* data:**T**, *out* output:**T**, *out* mask:**T**)|10+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(bool)|
| | |[7, 9]|**T** = tensor(double), tensor(float16), tensor(float)|
|DynamicSlice|(*in* data:**T**, *in* starts:**Tind**, *in* ends:**Tind**, *in* axes:**Tind**, *out* output:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|Elu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Equal|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|11+|**T** = tensor(int32), tensor(int64), tensor(bool)|
| | |[7, 10]|**T** = tensor(int32), tensor(int64), tensor(bool)|
|Erf|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(double), tensor(float16), tensor(float)|
|Exp|(*in* input:**T**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Expand|(*in* input:**T**, *in* shape:**tensor(int64)**, *out* output:**T**)|8+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|EyeLike|(*in* input:**T1**, *out* output:**T2**)|9+|**T1** = tensor(double), tensor(float), tensor(int64), tensor(uint64), tensor(int32)|
| | ||**T2** = tensor(double), tensor(float), tensor(int64), tensor(uint64), tensor(int32)|
|Flatten|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 8]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[9, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Floor|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|GRU|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *out* Y:**T**, *out* Y_h:**T**)|7+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(int32)|
|Gather|(*in* data:**T**, *in* indices:**Tind**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
| | |[1, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|GatherElements|(*in* data:**T**, *in* indices:**Tind**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|Gemm|(*in* A:**T**, *in* B:**T**, *in* C:**T**, *out* Y:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[7, 8]|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[9, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|GlobalAveragePool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|GlobalMaxPool|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Greater|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|9+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(bool)|
| | |[7, 8]|**T** = tensor(double), tensor(float16), tensor(float)|
|HardSigmoid|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Identity|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|If|(*in* cond:**B**, *out* outputs:**V**)|11+|**B** = tensor(bool)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**B** = tensor(bool)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|ImageScaler|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|InstanceNormalization|(*in* input:**T**, *in* scale:**T**, *in* B:**T**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|LRN|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|LSTM|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *in* initial_c:**T**, *in* P:**T**, *out* Y:**T**, *out* Y_h:**T**, *out* Y_c:**T**)|7+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(int32)|
|LayerNormalization|(*in* X:**T**, *in* scale:**T**, *in* B:**T**, *out* Y:**T**, *out* mean:**U**, *out* inv_std_var:**U**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**U** = tensor(float)|
|LeakyRelu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Less|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|9+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(bool)|
| | |[7, 8]|**T** = tensor(double), tensor(float16), tensor(float)|
|Log|(*in* input:**T**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Loop|(*in* M:**I**, *in* cond:**B**, *in* v_initial:**V**, *out* v_final_and_scan_outputs:**V**)|11+|**B** = tensor(bool)|
| | ||**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**B** = tensor(bool)|
| | ||**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|MatMul|(*in* A:**T**, *in* B:**T**, *out* Y:**T**)|9+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 8]|**T** = tensor(double), tensor(float16), tensor(float)|
|MatMulInteger|(*in* A:**T1**, *in* B:**T2**, *in* a_zero_point:**T1**, *in* b_zero_point:**T2**, *out* Y:**T3**)|10+|**T1** = tensor(int8)|
| | ||**T2** = tensor(int8)|
| | ||**T3** = tensor(int32)|
|Max|(*in* data_0:**T**, *out* max:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | |[6, 7]|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[8, 11]|**T** = tensor(double), tensor(float16), tensor(float)|
|MaxPool|(*in* X:**T**, *out* Y:**T**, *out* Indices:**I**) or (*in* X:**T**, *out* Y:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int8), tensor(uint8), tensor(float16)|
| | |[1, 7]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float16), tensor(float)|
| | |[10, 10]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float16), tensor(float)|
| | |[11, 11]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float16), tensor(float)|
| | |[8, 9]|**I** = tensor(int64)|
| | ||**T** = tensor(double), tensor(float16), tensor(float)|
|MemcpyFromHost|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|MemcpyToHost|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Min|(*in* data_0:**T**, *out* min:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | |[6, 7]|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[8, 11]|**T** = tensor(double), tensor(float16), tensor(float)|
|Mul|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
|Neg|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(int16), tensor(float16), tensor(int32)|
|NonZero|(*in* X:**T**, *out* Y:**tensor(int64)**)|9+|**T** = tensor(float), tensor(int64), tensor(uint8), tensor(bool), tensor(int32)|
|Not|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|Or|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|7+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
|PRelu|(*in* X:**T**, *in* slope:**T**, *out* Y:**T**)|7+|**T** = tensor(double), tensor(float16), tensor(float)|
|Pad|(*in* data:**T**, *in* pads:**tensor(int64)**, *in* constant_value:**T**, *out* output:**T**) or (*in* data:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[2, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|ParametricSoftplus|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Pow|(*in* X:**T**, *in* Y:**T**, *out* Z:**T**) or (*in* X:**T**, *in* Y:**T1**, *out* Z:**T**)|7+|**T** = tensor(double), tensor(float16), tensor(float)|
|QuantizeLinear|(*in* x:**T1**, *in* y_scale:**tensor(float)**, *in* y_zero_point:**T2**, *out* y:**T2**)|10+|**T1** = tensor(float)|
| | ||**T2** = tensor(int8), tensor(uint8)|
|RNN|(*in* X:**T**, *in* W:**T**, *in* R:**T**, *in* B:**T**, *in* sequence_lens:**T1**, *in* initial_h:**T**, *out* Y:**T**, *out* Y_h:**T**)|7+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(int32)|
|Range|(*in* start:**T**, *in* limit:**T**, *in* delta:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(float), tensor(int64), tensor(int16), tensor(int32)|
|Reciprocal|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|ReduceL1|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceL2|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceLogSum|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|ReduceLogSumExp|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|ReduceMax|(*in* data:**T**, *out* reduced:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int8), tensor(uint8), tensor(float16), tensor(int32)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[11, 11]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceMean|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceMin|(*in* data:**T**, *out* reduced:**T**)|12+|**T** = tensor(double), tensor(float), tensor(int8), tensor(uint8), tensor(float16), tensor(int32)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[11, 11]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceProd|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceSum|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(int32), tensor(float16), tensor(float)|
|ReduceSumSquare|(*in* data:**T**, *out* reduced:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|Relu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Reshape|(*in* data:**T**, *in* shape:**tensor(int64)**, *out* reshaped:**T**) or (*in* data:**T**, *out* reshaped:**T**)|5+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**shape** = tensor(int64)|
|Reshape_1||[1, 4]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Resize|(*in* X:**T1**, *in* roi:**T2**, *in* scales:**tensor(float)**, *in* sizes:**tensor(int64)**, *out* Y:**T1**) or (*in* X:**T**, *in* scales:**tensor(float)**, *out* Y:**T**)|11+|**T1** = tensor(double), tensor(float), tensor(uint8), tensor(float16), tensor(int32)|
| | |[10, 10]|**T** = tensor(double), tensor(float), tensor(uint8), tensor(float16), tensor(int32)|
|ReverseSequence|(*in* input:**T**, *in* sequence_lens:**tensor(int64)**, *out* Y:**T**)|10+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|RoiAlign|(*in* X:**T1**, *in* rois:**T1**, *in* batch_indices:**T2**, *out* Y:**T1**)|10+|**T** = tensor(double), tensor(float)|
| | ||**T2** = tensor(int64)|
|Round|(*in* X:**T**, *out* Y:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
|ScaledTanh|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Scan|(*in* sequence_lens:**I**, *in* initial_state_and_scan_inputs:**V**, *out* final_state_and_scan_outputs:**V**) or (*in* initial_state_and_scan_inputs:**V**, *out* final_state_and_scan_outputs:**V**)|11+|**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[8, 8]|**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(string), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[9, 10]|**I** = tensor(int64)|
| | ||**V** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Scatter|(*in* data:**T**, *in* indices:**Tind**, *in* updates:**T**, *out* output:**T**)|[9, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|ScatterElements|(*in* data:**T**, *in* indices:**Tind**, *in* updates:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64)|
|Selu|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Shape|(*in* data:**T**, *out* shape:**T1**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**T1** = tensor(int64)|
|Shrink|(*in* input:**T**, *out* output:**T**)|9+|**T** = tensor(double), tensor(float), tensor(int8), tensor(int64), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(uint64), tensor(int32)|
|Sigmoid|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Slice|(*in* data:**T**, *in* starts:**Tind**, *in* ends:**Tind**, *in* axes:**Tind**, *in* steps:**Tind**, *out* output:**T**) or (*in* data:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64), tensor(float)|
| | |[1, 9]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64), tensor(float)|
| | |[10, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | ||**Tind** = tensor(int32), tensor(int64), tensor(float)|
|Softmax|(*in* input:**T**, *out* output:**T**)|11+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |[1, 10]|**T** = tensor(double), tensor(float16), tensor(float)|
|Softplus|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Softsign|(*in* input:**T**, *out* output:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Split|(*in* input:**T**, *in* split:**T**, *out* outputs...:**T**) or (*in* input:**T**, *out* outputs:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[2, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Sqrt|(*in* X:**T**, *out* Y:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|Squeeze|(*in* data:**T**, *out* squeezed:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Sub|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|7+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
|Sum|(*in* data_0:**T**, *out* sum:**T**)|8+|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
| | |[6, 7]|**T** = tensor(double), tensor(float), tensor(int64), tensor(uint32), tensor(float16), tensor(uint64), tensor(int32)|
|Tanh|(*in* input:**T**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
|ThresholdedRelu|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
| | |10+|**T** = tensor(double), tensor(float16), tensor(float)|
|Tile|(*in* input:**T**, *in* tiles:**T**, *in* axis:**T**, *out* output:**T**) or (*in* input:**T**, *in* repeats:**T1**, *out* output:**T**)|6+|**T** = tensor(double), tensor(float16), tensor(float)|
| | ||**T1** = tensor(int64)|
|TopK|(*in* X:**T**, *in* K:**tensor(int64)**, *out* Values:**T**, *out* Indices:**I**) or (*in* X:**T**, *out* Values:**T**, *out* Indices:**I**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 9]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[10, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Transpose|(*in* data:**T**, *out* transposed:**T**)|1+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Unsqueeze|(*in* data:**T**, *out* expanded:**T**)|11+|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
| | |[1, 10]|**T** = tensor(double), tensor(bfloat16), tensor(float), tensor(int64), tensor(int8), tensor(uint8), tensor(int16), tensor(uint32), tensor(uint16), tensor(float16), tensor(bool), tensor(uint64), tensor(int32)|
|Upsample|(*in* X:**T**, *in* scales:**tensor(float)**, *out* Y:**T**) or (*in* X:**T**, *out* Y:**T**)|[7, 9]|**T** = tensor(double), tensor(float), tensor(uint8), tensor(float16), tensor(int32)|
|Where|(*in* condition:**B**, *in* X:**T**, *in* Y:**T**, *out* output:**T**)|9+|**B** = tensor(bool)|
| | ||**T** = tensor(float), tensor(int64), tensor(uint8), tensor(float16), tensor(int32)|
|Xor|(*in* A:**T**, *in* B:**T**, *out* C:**T1**)|7+|**T** = tensor(bool)|
| | ||**T1** = tensor(bool)|
| |
| |
**Operator Domain:** *com.microsoft*
|Attention|(*in* input:**T**, *in* weight:**T**, *in* bias:**T**, *in* mask_index:**M**, *out* output:**T**)|1+|**T** = tensor(float16), tensor(float)|
|BiasGelu|(*in* A:**T**, *in* B:**T**, *out* C:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|ConvTransposeWithDynamicPads|(*in* X:**T**, *in* W:**T**, *in* Pads:**tensor(int64)**, *in* B:**T**, *out* Y:**T**)|1+|**T** = tensor(float)|
|EmbedLayerNormalization|(*in* input_ids:**T1**, *in* segment_ids:**T1**, *in* word_embedding:**T**, *in* position_embedding:**T**, *in* segment_embedding:**T**, *in* gamma:**T**, *in* beta:**T**, *in* mask:**T1**, *out* output:**T**, *out* mask_index:**T1**)|1+|**T** = tensor(float16), tensor(float)|
|FastGelu|(*in* X:**T**, *in* bias:**T**, *out* Y:**T**)|1+|**T** = tensor(float16), tensor(float)|
|Gelu|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Irfft|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|Rfft|(*in* X:**T**, *out* Y:**T**)|1+|**T** = tensor(double), tensor(float16), tensor(float)|
|SkipLayerNormalization|(*in* input:**T**, *in* skip:**T**, *in* gamma:**T**, *in* beta:**T**, *in* bias:**T**, *out* output:**T**, *out* mean:**U**, *out* inv_std_var:**U**)|1+|**T** = tensor(float16), tensor(float)|
| |
| |


## Operators implemented by DnnlExecutionProvider

| Op Name | Parameters | OpSet Version | Types Supported |
|---------|------------|---------------|-----------------|
**Operator Domain:** *ai.onnx.ml*
|Gemm|(*in* A:**T**, *in* B:**T**, *in* C:**T**, *out* Y:**T**)|7+|**T** = tensor(float)|
| |
| |
